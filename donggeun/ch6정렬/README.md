# 정렬

# 기준에 따라 데이터를 정렬

## 정렬 알고리즘 개요

- `정렬`: 데이터를 특정한 기준에 따라서 순서대로 나열
- 데이터 가공에 필수적으로 사용될 때가 많기 때문에, 가장 많이 사용되는 알고리즘 중 하나
- 정렬된 데이터를 통해 `이진 탐색 (Binary Search)`가 가능해진다.

## 선택 정렬

- 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 변경, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 변경
- 매번 가장 작은 것을 **선택**: `선택 정렬 (Selection Sort)`

```python
for i in range(len(array)):
    min_index = i
    for j in range(i+1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i]
```

### 선택 정렬의 시간 복잡도

- `N + (N - 1) + (N -2 ) + ... + 1` -> `O(N^2)`
- 소스 코드 상에서 2중 반복문을 확인할 수 있다.

## 삽입 정렬

- 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 **삽입**
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 선택정렬에 비해 실행 시간 측면에서 더 효율적
- 특히, **데이터가 거의 정렬 되어 있을 때** 훨씬 효율적
    - `선택 정렬`은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾼다.
- 삽입 정렬의 과정에서, 앞 부분의 정렬이 이루어진 원소는 항상 오름차순을 유지하고 있다는 특징이 있다.

```python
for i in range(1, len(array)):
    for j in range(i, 0, -1): # 인덱스 i부터 1까지 --
        if array[j] < array[j-1]:
            array[j], array[j - 1] = array[j - 1], array[j]
        else:
            break 
```

### 삽입 정렬의 시간 복잡도

- 선택 정렬과 마찬가지로, 반복문이 2번 중첩되어 사용되었기에 `O(N^2)`이 소요된다.
- 하지만 앞서 언급했듯, 선택 정렬과 비교하여 삽입 정렬은 데이터가 거의 정렬되어 있을 경우에 장점을 갖는다.
    - 최선의 경우 `O(N)`의 시간 복잡도를 갖는다. = 특정한 경우 퀵 정렬 등의 알고리즘보다 강력한 방법이다.

## 퀵 정렬

- 지금까지 배운 정렬 알고리즘 중에 가장 많이 사용되는 알고리즘
    - 또 다른 많이 사용되는 알고리즘에는 `병합 정렬` 알고리즘이 있다.
- `피벗`을 기준으로, 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼다.
    - 한 차례 탐색이 끝나면, `피벗`을 작은 데이터와 변경해주고, 피벗을 기준으로 왼쪽과 오른쪽 파티션에 대해 반복하여 수행한다.

```python
def quick_sort(array, start, end):
    if start >= end:
        return
    pviot = start
    left = start + 1
    right = end
    while left <= right:
        while left <= end and array[left] <= array[pivot]:
            left += 1
        while right > start and array[right] >= array[pivot]:
            right -= 1
        if left > right:
            array[right], array[pivot] = array[pivot], array[right]
        else:
            array[left, array[right] = array[right], array[left]
    quick_srot(array, start, right - 1)
    quick_sort(array, right + 1, end)

quick_sort(array, 0, len(array) - 1)
```

### 퀵 정렬의 시간 복잡도

- 퀵 정렬의 평균 시간 복잡도는 `O(NlogN)`이다.
    - 약식으로 설명하자면, 분할이 절반 씩 된다고 가정하면 분할 횟수가 기하급수적으로 감소
    - 데이터가 `N`개 일 때, 높이는 `logN`이므로...
- 하지만, 최악의 경우 시간 복잡도는 `O(N^2)`이 된다.
- `피벗`을 가장 왼쪽 데이터로 삼을 경우, 이미 데이터가 정렬되어 있는 경우에 가장 느리게 동작한다.
    - 이런 점에서 `삽입 정렬`과 반대된다고 할 수 있다.
- 프로그래밍 언어들의 내장 라이브러리의 경우, 최악의 경우에도 `O(NlogN)`을 보장하도록 피벗값 설정에 대해 추가적인 로직을 더해준다.

## 계수 정렬

- `계수 정렬 (Count Sort)`: 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘
- 모든 데이터가 양의 정수 일 때, 데이터의 개수가 `N`, 데이터 중 최댓값이 `K`일 때, 최악의 경우에도 수행시간 `O(N+K)`를 보장한다.
- 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.
    - 모든 범위를 담을 수 있는 크기의 리스트를 선언해야 하기 때문
- 계수 정렬은 앞서 다루었던 비교 기반의 정렬 알고리즘이 아니다.
- 리스트에는 각 데이터가 몇 번 등장 했는지 횟수가 기록되고, 첫 데이터 부터 하나씩 그 값만큼 인덱스를 출력해주면 된다.

```python
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1

for i in range(len(count)):
    for j in range(count[i]):
        print(i, end=' ') 
```

### 계수 정렬의 시간 복잡도

- 데이터의 개수를 N, 데이터 중 최대값의 크기를 K (모든 데이터는 양수)라고 할 때, `O(N+K)`
- 기수 정렬과 더불어 현존하는 정렬 알고리즘 중에서 가장 빠르다.
    - 기수 정렬은 계수 정렬에 비해 동작은 느리지만, 처리할 수 있는 정수의 크기는 더 크다. (원리는 조금 더 복잡)

### 계수 정렬의 공간 복잡도

- 계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다.
- 예를 들어 데이터가 0과 999,999 단 2개만 존재할 때...
- 공간 복잡도 역시 `O(N+K)`이다.

## 자바의 정렬 라이브러리

- 찾아보기!

  ### 정렬 라이브러리의 시간 복잡도
    - 찾아보기!

# 문제

- 페이지: [이것이 취업을 위한 코딩 테스트다] 수록 페이지
- BJ: BAEKJOON 문제

|이름|페이지|코드|해결|
|:---:|:---:|:---:|:---:|
|위에서 아래로|178|[🚀](./위에서아래로.java)|✅|
|성적이 낮은 순서로 학생 출력하기|180|[🚀](./성적이낮은순서로학생출력하기.java)|✅|
|두 배열의 원소 교체|182|[🚀](./두배열의원소교체.java)|✅|
|[국영수](https://www.acmicpc.net/problem/10825)|359|[🚀](./국영수.java)|✅|
|[안테나](https://www.acmicpc.net/problem/18310)|360|[🚀](./안테나.java)|✅|
|[실패율](https://programmers.co.kr/learn/courses/30/lessons/42889)|361|[🚀](./실패율.java)|✅|
|[카드 정렬하기](https://www.acmicpc.net/problem/1715)|363|[🚀](./카드정렬하기.java)|✅|

