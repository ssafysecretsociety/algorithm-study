# 다이나믹 프로그래밍

## 중복되는 연산을 줄이자
- 컴퓨터를 활용해도 해결하기 어려운 문제: 최적 해를 구하기에 시간이나 메모리가 너무 많이 필요한 문제 (한정적)
- 어떤 문제의 경우, 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있다.
  - 대표적인 방법이 `다이나믹 프로그래밍 (Dynamic Programming)` 

  ### 피보나치 문제
  - 재귀를 활용한 기존 코드
  ```python
  def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)
  
  print(fibo(4)) 
  ```
  - 이런 코드의 경우, n이 커질 수록 수행 시간이 급격하게 증가한다. `O(2^n)` 이기 때문이다.
  - 위 코드의 문제점은 동일한 계산이 반복되어 수행되는 것이다.
    - `f(6)`을 계산하기 위해서는 동일한 과정의 `f(3)` 계산이 3번 수행된다.
  
  
- 이러한 문제를 다이나믹 프로그래밍을 통해 해결할 수 있다.
- DP가 적용 가능한 경우
  1. 큰 문제를 작은 문제로 나눌 수 있다.
  2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
- 피보나치 문제는 이러한 조건을 만족하는 대표 문제이다.

  ### 다이나믹 프로그래밍 기법 중 하나인 메모이제이션을 이용한 피보나치
  ```python
  # 한 번 계산된 결과를 메모이제이션 하기 위한 리스트 초기화
  d = [0] * 100
  
  # 탑다운 다이나믹 프로그래밍
  def fibo(x):
    # 종료조건 (1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]
  
  print(fibo(99))
  
  ```
  - DP를 사용한 피보나치는 시간 복잡도가 `O(N)`으로 단축된다.
  - 위 방식은 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 `탑다운 방식`이라고 한다.
  - 반복문을 이용해 작은 문제부터 차근차근 답을 도출하는 방법은 `보텀업 방식`이라고 하며 코드는 밑과 같다.
  ```python
  d = [0] * 100
  
  d[1] = 1
  d[2] = 1
  n = 99
  
  for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]
  
  print(d[n])
  ```


# 문제

- 페이지: [이것이 취업을 위한 코딩 테스트다] 수록 페이지
- BJ: BAEKJOON 문제


|이름|페이지|코드|해결|
|:---:|:---:|:---:|:---:|
|1로 만들기|217|[🚀](./일로만들기.java)|✅|
|개미 전사|220|[🚀](./개미전사.java)|✅|
|바닥 공사|223|[🚀](./바닥공사.java)|✅|
|효율적인 화폐 구성|226|[🚀](./효율적인화폐구성.java)|✅|
|금광|375|[🚀](./금광.java)|✅|
|[정수 삼각형](https://www.acmicpc.net/problem/1932)|376|[🚀](./정수삼각형.java)|✅|
|[퇴사](https://www.acmicpc.net/problem/14501)|377|[🚀](./퇴사.java)|✅|
|[병사 배치하기](https://www.acmicpc.net/problem/18353)|380|[🚀](./병사배치하기.java)||
|못생긴 수|381|[🚀](./못생긴수.java)|✅|
|편집 거리|382|[🚀](./편집거리.java)||
